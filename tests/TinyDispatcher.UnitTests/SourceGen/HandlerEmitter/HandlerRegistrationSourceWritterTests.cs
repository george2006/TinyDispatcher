#nullable enable

using TinyDispatcher.SourceGen.Emitters.Handlers;
using TinyDispatcher.SourceGen.Generator.Models;
using Xunit;

namespace TinyDispatcher.UnitTest.SourceGen.HandlerEmitter;

public sealed class HandlerRegistrationsSourceWriterTests
{
    [Fact]
    public void Write_emits_empty_partial_method_when_disabled()
    {
        var plan = HandlerRegistrationsPlan.Disabled("Acme.Gen");
        var sut = new HandlerRegistrationsSourceWriter();

        var src = sut.Write(plan);

        Assert.Contains("namespace Acme.Gen", src);
        Assert.Contains("internal static partial class ThisAssemblyPipelineContribution", src);
        Assert.Contains("static partial void AddGeneratedHandlers(IServiceCollection services) { }", src);
        Assert.DoesNotContain("ArgumentNullException", src);
        Assert.DoesNotContain("AddTransient", src);
    }

    [Fact]
    public void Write_emits_command_and_query_registrations_with_blank_line_between_blocks()
    {
        var plan = new HandlerRegistrationsPlan(
            @namespace: "Acme.Gen",
            isEnabled: true,
            commandContextFqn: "global::Acme.Ctx",
            commands: new[]
            {
                new HandlerContract("global::A.Cmd", "global::A.CmdHandler"),
            },
            queries: new[]
            {
                new QueryHandlerContract("global::A.Q", "global::A.R", "global::A.QHandler"),
            });

        var sut = new HandlerRegistrationsSourceWriter();

        var src = sut.Write(plan);

        Assert.Contains("// <auto-generated/>", src);
        Assert.Contains("using System;", src);
        Assert.Contains("using Microsoft.Extensions.DependencyInjection;", src);

        Assert.Contains("static partial void AddGeneratedHandlers(IServiceCollection services)", src);
        Assert.Contains("if (services is null) throw new ArgumentNullException(nameof(services));", src);

        var cmdLine =
            "services.AddTransient(typeof(global::TinyDispatcher.ICommandHandler<global::A.Cmd, global::Acme.Ctx>), typeof(global::A.CmdHandler));";
        var qryLine =
            "services.AddTransient(typeof(global::TinyDispatcher.IQueryHandler<global::A.Q, global::A.R>), typeof(global::A.QHandler));";

        Assert.Contains(cmdLine, src);
        Assert.Contains(qryLine, src);

        // Ensure the command registration appears before the query registration.
        var cmdIdx = src.IndexOf(cmdLine, System.StringComparison.Ordinal);
        var qryIdx = src.IndexOf(qryLine, System.StringComparison.Ordinal);

        Assert.True(cmdIdx >= 0);
        Assert.True(qryIdx >= 0);
        Assert.True(cmdIdx < qryIdx);

        // Ensure there is at least one blank line between the last command line and the first query line,
        // regardless of newline style (\n vs \r\n).
        var between = src.Substring(cmdIdx + cmdLine.Length, qryIdx - (cmdIdx + cmdLine.Length));
        var normalizedBetween = between.Replace("\r\n", "\n");

        Assert.Contains("\n\n", normalizedBetween);
    }

    [Fact]
    public void Write_does_not_insert_blank_line_when_only_commands_or_only_queries_exist()
    {
        var commandsOnly = new HandlerRegistrationsPlan(
            @namespace: "Acme.Gen",
            isEnabled: true,
            commandContextFqn: "global::Acme.Ctx",
            commands: new[] { new HandlerContract("global::A.Cmd", "global::A.CmdHandler") },
            queries: System.Array.Empty<QueryHandlerContract>());

        var sut = new HandlerRegistrationsSourceWriter();

        var src = sut.Write(commandsOnly);

        Assert.Contains("ICommandHandler<global::A.Cmd, global::Acme.Ctx>", src);
        Assert.DoesNotContain("IQueryHandler<", src);
    }
}