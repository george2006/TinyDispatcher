//
// Fixes:
// - Correct middleware execution order: Global (outermost) -> Policy -> Per-command -> Handler
// - Ensures that when a command has BOTH policy + per-command middleware, BOTH run (policy is included inside per-command pipeline)
// - Registers open-generic middleware types for ctor injection
// - Registers pipelines as Scoped (stateful)
//
// Contract hardening:
// - Single pipeline contract only: ICommandPipeline<TCommand,TContext>
// - Global + Policy pipelines implement ICommandPipeline<TCommand,TContext>
// - Generator registers exactly one ICommandPipeline<Cmd,Ctx> per command (per-command > policy > global)

#nullable enable

using Microsoft.CodeAnalysis.Text;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using TinyDispatcher.SourceGen.Abstractions;
using TinyDispatcher.SourceGen.Generator;
using TinyDispatcher.SourceGen.Generator.Models;

namespace TinyDispatcher.SourceGen.Emitters;

public sealed class PipelineEmitter : ICodeEmitter
{
    public sealed record PolicySpec(
        string PolicyTypeFqn,
        ImmutableArray<MiddlewareRef> Middlewares,
        ImmutableArray<string> Commands
    );

    private readonly ImmutableArray<MiddlewareRef> _globalMiddlewares;
    private readonly ImmutableDictionary<string, ImmutableArray<MiddlewareRef>> _perCommand;
    private readonly ImmutableDictionary<string, PolicySpec> _policies;

    public PipelineEmitter(
        ImmutableArray<MiddlewareRef> globalMiddlewares,
        ImmutableDictionary<string, ImmutableArray<MiddlewareRef>> perCommand,
        ImmutableDictionary<string, PolicySpec> policies)
    {
        _globalMiddlewares = globalMiddlewares;
        _perCommand = perCommand ?? ImmutableDictionary<string, ImmutableArray<MiddlewareRef>>.Empty;
        _policies = policies ?? ImmutableDictionary<string, PolicySpec>.Empty;
    }

    public void Emit(IGeneratorContext context, DiscoveryResult result, GeneratorOptions options)
    {
        if (options == null) return;
        if (string.IsNullOrWhiteSpace(options.CommandContextType)) return;

        var hasAny =
            (!_globalMiddlewares.IsDefaultOrEmpty && _globalMiddlewares.Length > 0) ||
            (_perCommand.Count > 0) ||
            (_policies.Count > 0);

        // If nothing exists, we emit nothing.
        // (Your EmptyPipelineContributionEmitter should still emit the host/wrapper.)
        if (!hasAny) return;

        var source = BuildSource(result, options);

        context.AddSource(
            hintName: "TinyDispatcherPipeline.g.cs",
            sourceText: SourceText.From(source, Encoding.UTF8));
    }

    private string BuildSource(DiscoveryResult result, GeneratorOptions options)
    {
        var sb = new StringBuilder(96_000);

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
        sb.AppendLine();

        sb.AppendLine("namespace " + options.GeneratedNamespace);
        sb.AppendLine("{");

        AppendPipelines(sb, result, options);
        sb.AppendLine("}");

        sb.AppendLine();
        AppendContributionPartial(sb, result, options);

        return sb.ToString();
    }

    // ============================================================
    // Pipelines
    // ============================================================

    private void AppendPipelines(StringBuilder sb, DiscoveryResult result, GeneratorOptions options)
    {
        var core = "global::TinyDispatcher";
        var ctx = NormalizeFullyQualifiedType(options.CommandContextType!);

        var globalMids = NormalizeDistinct(_globalMiddlewares);
        var hasGlobal = globalMids.Length > 0;

        // Normalize per-command map keys
        var perCmd = new Dictionary<string, MiddlewareRef[]>(StringComparer.Ordinal);
        foreach (var kv in _perCommand)
        {
            var cmd = NormalizeFullyQualifiedType(kv.Key);
            var mids = NormalizeDistinct(kv.Value);
            if (string.IsNullOrWhiteSpace(cmd) || mids.Length == 0) continue;
            perCmd[cmd] = mids;
        }

        // Build command -> policy middleware mapping (FIRST matching policy wins deterministically)
        var cmdToPolicyMids = BuildCommandToPolicyMiddlewares();

        // 1) Global pipeline (open TCommand)
        if (hasGlobal)
        {
            sb.AppendLine("  internal sealed class TinyDispatcherGlobalPipeline<TCommand> : " + core + ".ICommandPipeline<TCommand, " + ctx + ">");
            sb.AppendLine("      where TCommand : " + core + ".ICommand");
            sb.AppendLine("  {");

            for (int i = 0; i < globalMids.Length; i++)
            {
                var mw = globalMids[i];
                sb.AppendLine("    private readonly " + CloseMiddleware(mw, "TCommand", ctx) + " " + FieldName(mw) + ";");
            }

            sb.AppendLine("    private int _index;");
            sb.AppendLine("    private " + core + ".ICommandHandler<TCommand, " + ctx + ">? _handler;");
            sb.AppendLine("    private readonly Runtime _runtime;");
            sb.AppendLine();

            sb.AppendLine("    public TinyDispatcherGlobalPipeline(");
            for (int i = 0; i < globalMids.Length; i++)
            {
                var mw = globalMids[i];
                var comma = (i == globalMids.Length - 1) ? "" : ",";
                sb.AppendLine("        " + CloseMiddleware(mw, "TCommand", ctx) + " " + CtorParamName(mw) + comma);
            }
            sb.AppendLine("    )");
            sb.AppendLine("    {");
            for (int i = 0; i < globalMids.Length; i++)
            {
                var mw = globalMids[i];
                sb.AppendLine("      " + FieldName(mw) + " = " + CtorParamName(mw) + ";");
            }
            sb.AppendLine("      _runtime = new Runtime(this);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    public ValueTask ExecuteAsync(TCommand command, " + ctx + " ctxValue, " + core + ".ICommandHandler<TCommand, " + ctx + "> handler, CancellationToken ct = default)");
            sb.AppendLine("    {");
            sb.AppendLine("      if (command is null) throw new ArgumentNullException(nameof(command));");
            sb.AppendLine("      if (handler is null) throw new ArgumentNullException(nameof(handler));");
            sb.AppendLine("      _handler = handler;");
            sb.AppendLine("      _index = 0;");
            sb.AppendLine("      return NextAsync(command, ctxValue, ct);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    private ValueTask NextAsync(TCommand command, " + ctx + " ctxValue, CancellationToken ct)");
            sb.AppendLine("    {");
            sb.AppendLine("      switch (_index++)");
            sb.AppendLine("      {");
            for (int i = 0; i < globalMids.Length; i++)
            {
                var mw = globalMids[i];
                sb.AppendLine("        case " + i + ": return " + FieldName(mw) + ".InvokeAsync(command, ctxValue, _runtime, ct);");
            }
            sb.AppendLine("        default: return new ValueTask(_handler!.HandleAsync(command, ctxValue, ct));");
            sb.AppendLine("      }");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    private sealed class Runtime : " + core + ".Pipeline.ICommandPipelineRuntime<TCommand, " + ctx + ">");
            sb.AppendLine("    {");
            sb.AppendLine("      private readonly TinyDispatcherGlobalPipeline<TCommand> _p;");
            sb.AppendLine("      public Runtime(TinyDispatcherGlobalPipeline<TCommand> p) { _p = p; }");
            sb.AppendLine("      public ValueTask NextAsync(TCommand command, " + ctx + " ctxValue, CancellationToken ct = default)");
            sb.AppendLine("        { return _p.NextAsync(command, ctxValue, ct); }");
            sb.AppendLine("    }");

            sb.AppendLine("  }");
            sb.AppendLine();
        }

        // 2) Policy pipelines (open per policy)
        // IMPORTANT ORDER INSIDE POLICY PIPELINE: Global -> Policy -> Handler
        foreach (var p in _policies.Values.OrderBy(x => NormalizeFullyQualifiedType(x.PolicyTypeFqn), StringComparer.Ordinal))
        {
            var policyName = SanitizePolicyName(p.PolicyTypeFqn);
            var className = "TinyDispatcherPolicyPipeline_" + policyName;

            var policyMids = NormalizeDistinct(p.Middlewares);
            if (policyMids.Length == 0) continue;

            sb.AppendLine("  internal sealed class " + className + "<TCommand> : " + core + ".ICommandPipeline<TCommand, " + ctx + ">");
            sb.AppendLine("      where TCommand : " + core + ".ICommand");
            sb.AppendLine("  {");

            // fields: global first, then policy
            if (hasGlobal)
            {
                for (int i = 0; i < globalMids.Length; i++)
                {
                    var mw = globalMids[i];
                    sb.AppendLine("    private readonly " + CloseMiddleware(mw, "TCommand", ctx) + " " + FieldName(mw) + ";");
                }
            }
            for (int i = 0; i < policyMids.Length; i++)
            {
                var mw = policyMids[i];
                sb.AppendLine("    private readonly " + CloseMiddleware(mw, "TCommand", ctx) + " " + FieldName(mw) + ";");
            }

            sb.AppendLine("    private int _index;");
            sb.AppendLine("    private " + core + ".ICommandHandler<TCommand, " + ctx + ">? _handler;");
            sb.AppendLine("    private readonly Runtime _runtime;");
            sb.AppendLine();

            // ctor params in same order: global then policy (any order fine, but keep stable)
            sb.AppendLine("    public " + className + "(");
            var ctorList = new List<MiddlewareRef>();
            if (hasGlobal) ctorList.AddRange(globalMids);
            ctorList.AddRange(policyMids);

            for (int i = 0; i < ctorList.Count; i++)
            {
                var mw = ctorList[i];
                var comma = (i == ctorList.Count - 1) ? "" : ",";
                sb.AppendLine("        " + CloseMiddleware(mw, "TCommand", ctx) + " " + CtorParamName(mw) + comma);
            }
            sb.AppendLine("    )");
            sb.AppendLine("    {");
            for (int i = 0; i < ctorList.Count; i++)
            {
                var mw = ctorList[i];
                sb.AppendLine("      " + FieldName(mw) + " = " + CtorParamName(mw) + ";");
            }
            sb.AppendLine("      _runtime = new Runtime(this);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    public ValueTask ExecuteAsync(TCommand command, " + ctx + " ctxValue, " + core + ".ICommandHandler<TCommand, " + ctx + "> handler, CancellationToken ct = default)");
            sb.AppendLine("    {");
            sb.AppendLine("      if (command is null) throw new ArgumentNullException(nameof(command));");
            sb.AppendLine("      if (handler is null) throw new ArgumentNullException(nameof(handler));");
            sb.AppendLine("      _handler = handler;");
            sb.AppendLine("      _index = 0;");
            sb.AppendLine("      return NextAsync(command, ctxValue, ct);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    private ValueTask NextAsync(TCommand command, " + ctx + " ctxValue, CancellationToken ct)");
            sb.AppendLine("    {");
            sb.AppendLine("      switch (_index++)");
            sb.AppendLine("      {");
            int idx = 0;

            // ORDER: global outermost
            if (hasGlobal)
            {
                for (int i = 0; i < globalMids.Length; i++)
                {
                    var mw = globalMids[i];
                    sb.AppendLine("        case " + (idx++) + ": return " + FieldName(mw) + ".InvokeAsync(command, ctxValue, _runtime, ct);");
                }
            }

            // then policy
            for (int i = 0; i < policyMids.Length; i++)
            {
                var mw = policyMids[i];
                sb.AppendLine("        case " + (idx++) + ": return " + FieldName(mw) + ".InvokeAsync(command, ctxValue, _runtime, ct);");
            }

            sb.AppendLine("        default: return new ValueTask(_handler!.HandleAsync(command, ctxValue, ct));");
            sb.AppendLine("      }");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    private sealed class Runtime : " + core + ".Pipeline.ICommandPipelineRuntime<TCommand, " + ctx + ">");
            sb.AppendLine("    {");
            sb.AppendLine("      private readonly " + className + "<TCommand> _p;");
            sb.AppendLine("      public Runtime(" + className + "<TCommand> p) { _p = p; }");
            sb.AppendLine("      public ValueTask NextAsync(TCommand command, " + ctx + " ctxValue, CancellationToken ct = default)");
            sb.AppendLine("        { return _p.NextAsync(command, ctxValue, ct); }");
            sb.AppendLine("    }");

            sb.AppendLine("  }");
            sb.AppendLine();
        }

        // 3) Per-command pipelines (closed command type)
        // IMPORTANT:
        // - Order: Global -> Policy -> Per-command -> Handler
        // - Includes policy middleware if the command is in a policy
        foreach (var kv in perCmd.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            var cmdFqn = kv.Key;
            var perCmdMids = kv.Value;

            MiddlewareRef[] policyMidsForCommand;
            if (!cmdToPolicyMids.TryGetValue(cmdFqn, out policyMidsForCommand))
                policyMidsForCommand = Array.Empty<MiddlewareRef>();

            var className = "TinyDispatcherPipeline_" + SanitizeCommandName(cmdFqn);

            sb.AppendLine("  internal sealed class " + className + " : " + core + ".ICommandPipeline<" + cmdFqn + ", " + ctx + ">");
            sb.AppendLine("  {");

            // fields: global first, then policy, then per-command
            if (hasGlobal)
            {
                for (int i = 0; i < globalMids.Length; i++)
                {
                    var mw = globalMids[i];
                    sb.AppendLine("    private readonly " + CloseMiddleware(mw, cmdFqn, ctx) + " " + FieldName(mw) + ";");
                }
            }

            for (int i = 0; i < policyMidsForCommand.Length; i++)
            {
                var mw = policyMidsForCommand[i];
                sb.AppendLine("    private readonly " + CloseMiddleware(mw, cmdFqn, ctx) + " " + FieldName(mw) + ";");
            }

            for (int i = 0; i < perCmdMids.Length; i++)
            {
                var mw = perCmdMids[i];
                sb.AppendLine("    private readonly " + CloseMiddleware(mw, cmdFqn, ctx) + " " + FieldName(mw) + ";");
            }

            sb.AppendLine("    private int _index;");
            sb.AppendLine("    private " + core + ".ICommandHandler<" + cmdFqn + ", " + ctx + ">? _handler;");
            sb.AppendLine("    private readonly Runtime _runtime;");
            sb.AppendLine();

            // ctor: global + policy + per-command
            sb.AppendLine("    public " + className + "(");

            var ctorAll = new List<MiddlewareRef>();
            if (hasGlobal) ctorAll.AddRange(globalMids);
            ctorAll.AddRange(policyMidsForCommand);
            ctorAll.AddRange(perCmdMids);

            for (int i = 0; i < ctorAll.Count; i++)
            {
                var mw = ctorAll[i];
                var comma = (i == ctorAll.Count - 1) ? "" : ",";
                sb.AppendLine("        " + CloseMiddleware(mw, cmdFqn, ctx) + " " + CtorParamName(mw) + comma);
            }

            sb.AppendLine("    )");
            sb.AppendLine("    {");
            for (int i = 0; i < ctorAll.Count; i++)
            {
                var mw = ctorAll[i];
                sb.AppendLine("      " + FieldName(mw) + " = " + CtorParamName(mw) + ";");
            }
            sb.AppendLine("      _runtime = new Runtime(this);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    public ValueTask ExecuteAsync(" + cmdFqn + " command, " + ctx + " ctxValue, " + core + ".ICommandHandler<" + cmdFqn + ", " + ctx + "> handler, CancellationToken ct = default)");
            sb.AppendLine("    {");
            sb.AppendLine("      if (command is null) throw new ArgumentNullException(nameof(command));");
            sb.AppendLine("      if (handler is null) throw new ArgumentNullException(nameof(handler));");
            sb.AppendLine("      _handler = handler;");
            sb.AppendLine("      _index = 0;");
            sb.AppendLine("      return NextAsync(command, ctxValue, ct);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    private ValueTask NextAsync(" + cmdFqn + " command, " + ctx + " ctxValue, CancellationToken ct)");
            sb.AppendLine("    {");
            sb.AppendLine("      switch (_index++)");
            sb.AppendLine("      {");
            int stepIndex = 0;

            // ORDER: global -> policy -> per-command
            if (hasGlobal)
            {
                for (int i = 0; i < globalMids.Length; i++)
                {
                    var mw = globalMids[i];
                    sb.AppendLine("        case " + (stepIndex++) + ": return " + FieldName(mw) + ".InvokeAsync(command, ctxValue, _runtime, ct);");
                }
            }

            for (int i = 0; i < policyMidsForCommand.Length; i++)
            {
                var mw = policyMidsForCommand[i];
                sb.AppendLine("        case " + (stepIndex++) + ": return " + FieldName(mw) + ".InvokeAsync(command, ctxValue, _runtime, ct);");
            }

            for (int i = 0; i < perCmdMids.Length; i++)
            {
                var mw = perCmdMids[i];
                sb.AppendLine("        case " + (stepIndex++) + ": return " + FieldName(mw) + ".InvokeAsync(command, ctxValue, _runtime, ct);");
            }

            sb.AppendLine("        default: return new ValueTask(_handler!.HandleAsync(command, ctxValue, ct));");
            sb.AppendLine("      }");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    private sealed class Runtime : " + core + ".Pipeline.ICommandPipelineRuntime<" + cmdFqn + ", " + ctx + ">");
            sb.AppendLine("    {");
            sb.AppendLine("      private readonly " + className + " _p;");
            sb.AppendLine("      public Runtime(" + className + " p) { _p = p; }");
            sb.AppendLine("      public ValueTask NextAsync(" + cmdFqn + " command, " + ctx + " ctxValue, CancellationToken ct = default)");
            sb.AppendLine("        { return _p.NextAsync(command, ctxValue, ct); }");
            sb.AppendLine("    }");

            sb.AppendLine("  }");
            sb.AppendLine();
        }
    }

    // ============================================================
    // Contribution registrations
    // ============================================================

    private void AppendContributionPartial(StringBuilder sb, DiscoveryResult result, GeneratorOptions options)
    {
        var core = "global::TinyDispatcher";
        var ctx = NormalizeFullyQualifiedType(options.CommandContextType!);
        var genNs = "global::" + options.GeneratedNamespace;

        var globalMids = NormalizeDistinct(_globalMiddlewares);
        var hasGlobal = globalMids.Length > 0;

        // Normalize per-command set
        var perCmdSet = new HashSet<string>(StringComparer.Ordinal);
        foreach (var k in _perCommand.Keys)
        {
            var cmd = NormalizeFullyQualifiedType(k);
            if (!string.IsNullOrWhiteSpace(cmd)) perCmdSet.Add(cmd);
        }

        // command -> policy pipeline type open (first match wins)
        var cmdToPolicyPipelineOpen = new Dictionary<string, string>(StringComparer.Ordinal);
        foreach (var p in _policies.Values.OrderBy(x => NormalizeFullyQualifiedType(x.PolicyTypeFqn), StringComparer.Ordinal))
        {
            var policyName = SanitizePolicyName(p.PolicyTypeFqn);
            var policyPipelineOpen = genNs + ".TinyDispatcherPolicyPipeline_" + policyName;

            for (int i = 0; i < p.Commands.Length; i++)
            {
                var cmd = NormalizeFullyQualifiedType(p.Commands[i]);
                if (string.IsNullOrWhiteSpace(cmd)) continue;
                if (!cmdToPolicyPipelineOpen.ContainsKey(cmd))
                    cmdToPolicyPipelineOpen[cmd] = policyPipelineOpen;
            }
        }

        var policyCmdSet = new HashSet<string>(cmdToPolicyPipelineOpen.Keys, StringComparer.Ordinal);

        // Collect all middleware open generics for registration
        var allMw = new List<MiddlewareRef>();
        allMw.AddRange(globalMids);

        foreach (var kv in _perCommand)
            allMw.AddRange(NormalizeDistinct(kv.Value));

        foreach (var p in _policies.Values)
            allMw.AddRange(NormalizeDistinct(p.Middlewares));

        var allDistinct = NormalizeDistinct(allMw.ToImmutableArray());

        sb.AppendLine("namespace " + options.GeneratedNamespace);
        sb.AppendLine("{");
        sb.AppendLine("  internal static partial class ThisAssemblyPipelineContribution");
        sb.AppendLine("  {");
        sb.AppendLine("    static partial void AddGeneratedPipelines(IServiceCollection services)");
        sb.AppendLine("    {");
        sb.AppendLine("      if (services is null) throw new ArgumentNullException(nameof(services));");
        sb.AppendLine();

        if (allDistinct.Length > 0)
        {
            sb.AppendLine("      // Middleware open-generic registrations (required for generated pipelines ctor injection)");
            for (int i = 0; i < allDistinct.Length; i++)
            {
                var mw = allDistinct[i];
                sb.AppendLine("      services.TryAddTransient(typeof(" + OpenGenericTypeof(mw) + "));");
            }
            sb.AppendLine();
        }

        // Per-command pipelines (Scoped)
        foreach (var cmd in perCmdSet.OrderBy(x => x, StringComparer.Ordinal))
        {
            var className = "TinyDispatcherPipeline_" + SanitizeCommandName(cmd);
            sb.AppendLine("      services.AddScoped<" + core + ".ICommandPipeline<" + cmd + ", " + ctx + ">, " + genNs + "." + className + ">();");
        }

        // Policy pipelines ONLY for commands without per-command pipeline
        foreach (var cmd in policyCmdSet.OrderBy(x => x, StringComparer.Ordinal))
        {
            if (perCmdSet.Contains(cmd)) continue;

            var open = cmdToPolicyPipelineOpen[cmd];
            sb.AppendLine("      services.AddScoped<" + core + ".ICommandPipeline<" + cmd + ", " + ctx + ">, " + open + "<" + cmd + ">>();");
        }

        // Global pipelines for remaining commands
        if (hasGlobal && result != null && result.Commands.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("      // Global pipeline registrations (commands without per-command overrides or policy pipelines)");
            for (int i = 0; i < result.Commands.Length; i++)
            {
                var cmd = NormalizeFullyQualifiedType(result.Commands[i].MessageTypeFqn);
                if (string.IsNullOrWhiteSpace(cmd)) continue;

                if (perCmdSet.Contains(cmd)) continue;
                if (policyCmdSet.Contains(cmd)) continue;

                sb.AppendLine("      services.AddScoped<" + core + ".ICommandPipeline<" + cmd + ", " + ctx + ">, " + genNs + ".TinyDispatcherGlobalPipeline<" + cmd + ">>();");
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("  }");
        sb.AppendLine("}");
    }

    // ============================================================
    // Helper: build per-command policy middleware map
    // ============================================================

    private Dictionary<string, MiddlewareRef[]> BuildCommandToPolicyMiddlewares()
    {
        var map = new Dictionary<string, MiddlewareRef[]>(StringComparer.Ordinal);

        foreach (var p in _policies.Values.OrderBy(x => NormalizeFullyQualifiedType(x.PolicyTypeFqn), StringComparer.Ordinal))
        {
            var mids = NormalizeDistinct(p.Middlewares);
            if (mids.Length == 0) continue;

            for (int i = 0; i < p.Commands.Length; i++)
            {
                var cmd = NormalizeFullyQualifiedType(p.Commands[i]);
                if (string.IsNullOrWhiteSpace(cmd)) continue;

                if (!map.ContainsKey(cmd))
                    map[cmd] = mids; // first wins
            }
        }

        return map;
    }

    // ============================================================
    // Helpers (C#7 / netstandard2-safe)
    // ============================================================

    private static MiddlewareRef[] NormalizeDistinct(ImmutableArray<MiddlewareRef> items)
    {
        if (items.IsDefaultOrEmpty) return Array.Empty<MiddlewareRef>();

        var list = new List<MiddlewareRef>(items.Length);
        for (int i = 0; i < items.Length; i++)
        {
            var x = items[i];
            if (x == null) continue;

            var fqn = x.OpenTypeFqn;
            if (string.IsNullOrWhiteSpace(fqn)) continue;

            list.Add(new MiddlewareRef(NormalizeFullyQualifiedType(fqn), x.Arity));
        }

        // Distinct by (OpenTypeFqn, Arity)
        var distinct = list
            .GroupBy(m => m.OpenTypeFqn + "|" + m.Arity.ToString(), StringComparer.Ordinal)
            .Select(g => g.First())
            .OrderBy(m => m.OpenTypeFqn, StringComparer.Ordinal)
            .ToArray();

        return distinct;
    }

    private static string NormalizeFullyQualifiedType(string typeName)
    {
        if (string.IsNullOrWhiteSpace(typeName))
            return string.Empty;

        var trimmed = typeName.Trim();

        if (!trimmed.StartsWith("global::", StringComparison.Ordinal))
            trimmed = "global::" + trimmed;

        if (trimmed.StartsWith("global::global::", StringComparison.Ordinal))
            trimmed = "global::" + trimmed.Substring("global::global::".Length);

        return trimmed;
    }

    private static string CloseMiddleware(MiddlewareRef mw, string cmd, string ctx)
    {
        if (mw.Arity == 2) return mw.OpenTypeFqn + "<" + cmd + ", " + ctx + ">";
        return mw.OpenTypeFqn + "<" + cmd + ">";
    }

    private static string OpenGenericTypeof(MiddlewareRef mw)
    {
        if (mw.Arity == 2) return mw.OpenTypeFqn + "<,>";
        return mw.OpenTypeFqn + "<>";
    }

    private static string FieldName(MiddlewareRef mw)
    {
        return "_" + CtorParamName(mw);
    }

    private static string CtorParamName(MiddlewareRef mw)
    {
        var open = mw.OpenTypeFqn ?? string.Empty;

        var lastDot = open.LastIndexOf('.');
        var shortName = lastDot >= 0 ? open.Substring(lastDot + 1) : open;

        // strip `2
        var tick = shortName.IndexOf('`');
        if (tick >= 0)
            shortName = shortName.Substring(0, tick);

        if (shortName.EndsWith("Middleware", StringComparison.Ordinal))
            shortName = shortName.Substring(0, shortName.Length - "Middleware".Length);

        if (string.IsNullOrWhiteSpace(shortName))
            shortName = "Middleware";

        if (shortName.Length == 1)
            return char.ToLowerInvariant(shortName[0]).ToString();

        return char.ToLowerInvariant(shortName[0]) + shortName.Substring(1);
    }

    private static string SanitizeCommandName(string cmdFqn)
    {
        var s = cmdFqn;
        if (s.StartsWith("global::", StringComparison.Ordinal))
            s = s.Substring("global::".Length);

        var lastDot = s.LastIndexOf('.');
        var name = lastDot >= 0 ? s.Substring(lastDot + 1) : s;

        var chars = name.Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray();
        return new string(chars);
    }

    private static string SanitizePolicyName(string policyTypeFqn)
    {
        var s = policyTypeFqn;
        if (s.StartsWith("global::", StringComparison.Ordinal))
            s = s.Substring("global::".Length);

        var chars = s.Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray();
        return new string(chars);
    }
}
