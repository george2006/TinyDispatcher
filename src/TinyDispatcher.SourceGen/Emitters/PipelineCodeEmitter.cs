// File: PipelineEmitter.cs
// ------------------------------------------------------------
// Emits into the CONSUMER project:
//
// - TinyDispatcherGlobalPipeline<TCommand>                     [if global middleware exists]
// - TinyDispatcherPipeline_<Command>                           [if per-command middleware exists]
// - TinyDispatcherPolicyPipeline_<Policy><TCommand>            [if policy exists]
// - Implements: ThisAssemblyPipelineContribution.AddGeneratedPipelines(IServiceCollection)
//
// IMPORTANT:
// - The wrapper ThisAssemblyPipelineContribution.Add(IServiceCollection) is emitted ONLY
//   by EmptyPipelineContributionEmitter to avoid duplicate type emission.
// - This emitter ONLY provides the partial method implementation.
// ------------------------------------------------------------

#nullable enable

using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using TinyDispatcher.SourceGen.Abstractions;
using TinyDispatcher.SourceGen.Generator;
using TinyDispatcher.SourceGen.Generator.Models;
using TinyDispatcher.SourceGen.PipelineMap;
using TinyDispatcher.SourceGen.PipelineMaps;

namespace TinyDispatcher.SourceGen;

public sealed class PipelineEmitter : ICodeEmitter
{
    public sealed record PolicySpec(
        string PolicyTypeFqn,
        ImmutableArray<MiddlewareRef> Middlewares, // open generic middleware fqns
        ImmutableArray<string> Commands     // command fqns
    );

    private readonly ImmutableArray<MiddlewareRef> _globalMiddlewares; // open generic fqn
    private readonly ImmutableDictionary<string, ImmutableArray<MiddlewareRef>> _perCommand; // cmd fqn -> [open generic fqn]
    private readonly ImmutableDictionary<string, PolicySpec> _policies; // policy fqn -> spec

    public PipelineEmitter(
        ImmutableArray<MiddlewareRef> globalMiddlewares,
        ImmutableDictionary<string, ImmutableArray<MiddlewareRef>> perCommand,
        ImmutableDictionary<string, PolicySpec> policies)
    {
        _globalMiddlewares = globalMiddlewares;
        _perCommand = perCommand ?? ImmutableDictionary<string, ImmutableArray<MiddlewareRef>>.Empty;
        _policies = policies ?? ImmutableDictionary<string, PolicySpec>.Empty;
    }

    public void Emit(IGeneratorContext context, DiscoveryResult result, GeneratorOptions options)
    {
        if (string.IsNullOrWhiteSpace(options.CommandContextType))
            return;

        var hasAny =
            (!_globalMiddlewares.IsDefaultOrEmpty && _globalMiddlewares.Length > 0) ||
            (_perCommand.Count > 0) ||
            (_policies.Count > 0);

        // IMPORTANT: if nothing exists, we emit NOTHING.
        // The always-emitted EmptyPipelineContributionEmitter provides the no-op.
        if (!hasAny)
            return;

        var source = BuildSourceWithPipelines(result, options);

        if (options.EmitPipelineMap)
        {
            // For each discovered command handler, generate a map.
            // (If you prefer: only map commands that actually have any middleware/policy.)
            foreach (var c in result.Commands)
            {
                var resolved = ResolvePipelineForCommand(
                    commandFqn: c.MessageTypeFqn,
                    ctxFqn: options.CommandContextType!,
                    handlerFqn: c.HandlerTypeFqn);

                var descriptor = ToDescriptor(resolved);

                // Format gate: json
                if ((options.PipelineMapFormat ?? "json")
                    .IndexOf("json", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    PipelineMapJsonEmitter.Emit(context, descriptor);
                }
                if ((options.PipelineMapFormat ?? "")
                    .IndexOf("mermaid", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    PipelineMapMermaidEmitter.Emit(context, descriptor);
                }
            }
        }

        context.AddSource(
            hintName: "TinyDispatcherPipeline.g.cs",
            sourceText: SourceText.From(source, Encoding.UTF8));


    }

    private string BuildSourceWithPipelines(DiscoveryResult result, GeneratorOptions options)
    {
        var sb = new StringBuilder(64_000);

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();

        // Pipelines go under GeneratedNamespace
        sb.AppendLine($"namespace {options.GeneratedNamespace}");
        sb.AppendLine("{");
        AppendPipelines(sb, options);
        sb.AppendLine("}");
        sb.AppendLine();

        // Partial hook implementation MUST be in SAME namespace/type as empty emitter.
        // EmptyPipelineContributionEmitter emits:
        //   namespace TinyDispatcher.Generated { internal static partial class ThisAssemblyPipelineContribution { ... } }
        AppendContributionPartialImplementation(sb, result, options);

        return sb.ToString();
    }

    // ============================================================
    // PIPELINES
    // ============================================================

    private void AppendPipelines(StringBuilder sb, GeneratorOptions options)
    {
        var core = $"global::{Known.CoreNamespace}";
        var ctx = options.CommandContextType!;

        var globals = NormalizeDistinct(_globalMiddlewares);
        var hasGlobal = globals.Length > 0;

        var perCmd = _perCommand
            .Where(kv => !string.IsNullOrWhiteSpace(kv.Key) && !kv.Value.IsDefaultOrEmpty)
            .ToDictionary(
                kv => NormalizeFullyQualifiedType(kv.Key),
                kv => NormalizeDistinct(kv.Value),
                StringComparer.Ordinal);

        // -------------------------
        // 1) Global pipeline (open)
        // -------------------------
        if (hasGlobal)
        {
            sb.AppendLine("  internal sealed class TinyDispatcherGlobalPipeline<TCommand> : " +
                          $"{core}.IGlobalCommandPipeline<TCommand, {ctx}>");
            sb.AppendLine($"      where TCommand : {core}.ICommand");
            sb.AppendLine("  {");
            sb.AppendLine("    private readonly IServiceProvider _sp;");
            sb.AppendLine();
            sb.AppendLine("    public TinyDispatcherGlobalPipeline(IServiceProvider sp) => _sp = sp ?? throw new ArgumentNullException(nameof(sp));");
            sb.AppendLine();
            sb.AppendLine("    public Task ExecuteAsync(");
            sb.AppendLine("        TCommand command,");
            sb.AppendLine($"        {ctx} ctxValue,");
            sb.AppendLine($"        {core}.ICommandHandler<TCommand, {ctx}> handler,");
            sb.AppendLine("        CancellationToken ct = default)");
            sb.AppendLine("    {");
            sb.AppendLine("      if (command is null) throw new ArgumentNullException(nameof(command));");
            sb.AppendLine("      if (handler is null) throw new ArgumentNullException(nameof(handler));");
            sb.AppendLine();
            sb.AppendLine($"      {core}.CommandDelegate<TCommand, {ctx}> next = handler.HandleAsync;");
            sb.AppendLine();
            sb.AppendLine("      // Global middleware (outer)");
            foreach (var mwOpen in globals)
                sb.AppendLine($"      next = {StepName(mwOpen.OpenTypeFqn)}(next);");
            sb.AppendLine();
            sb.AppendLine("      return next(command, ctxValue, ct);");
            sb.AppendLine("    }");
            sb.AppendLine();

            foreach (var mwOpen in globals)
            {
                var step = StepName(mwOpen.OpenTypeFqn);
                sb.AppendLine($"    private {core}.CommandDelegate<TCommand, {ctx}> {step}({core}.CommandDelegate<TCommand, {ctx}> inner)");
                sb.AppendLine("    {");
                sb.AppendLine($"      return (cmd, ctxValue, ct) => _sp.GetRequiredService<{CloseMiddleware(mwOpen, "TCommand", ctx)}>()");
                sb.AppendLine("        .InvokeAsync(cmd, ctxValue, inner, ct);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            sb.AppendLine("  }");
            sb.AppendLine();
        }

        // -------------------------
        // 2) Policy pipelines (open per policy, reusable across many commands)
        //    Name is based on POLICY, not command.
        // -------------------------
        foreach (var p in _policies.Values.OrderBy(x => x.PolicyTypeFqn, StringComparer.Ordinal))
        {
            var policyName = SanitizePolicyName(p.PolicyTypeFqn);
            var className = $"TinyDispatcherPolicyPipeline_{policyName}";
            var mids = NormalizeDistinct(p.Middlewares);

            sb.AppendLine($"  internal sealed class {className}<TCommand> : {core}.IPolicyCommandPipeline<TCommand, {ctx}>");
            sb.AppendLine($"      where TCommand : {core}.ICommand");
            sb.AppendLine("  {");
            sb.AppendLine("    private readonly IServiceProvider _sp;");
            sb.AppendLine();
            sb.AppendLine($"    public {className}(IServiceProvider sp) => _sp = sp ?? throw new ArgumentNullException(nameof(sp));");
            sb.AppendLine();
            sb.AppendLine("    public Task ExecuteAsync(");
            sb.AppendLine("        TCommand command,");
            sb.AppendLine($"        {ctx} ctxValue,");
            sb.AppendLine($"        {core}.ICommandHandler<TCommand, {ctx}> handler,");
            sb.AppendLine("        CancellationToken ct = default)");
            sb.AppendLine("    {");
            sb.AppendLine("      if (command is null) throw new ArgumentNullException(nameof(command));");
            sb.AppendLine("      if (handler is null) throw new ArgumentNullException(nameof(handler));");
            sb.AppendLine();
            sb.AppendLine($"      {core}.CommandDelegate<TCommand, {ctx}> next = handler.HandleAsync;");
            sb.AppendLine();
            sb.AppendLine("      // Policy middleware (inner)");
            foreach (var mwOpen in mids)
                sb.AppendLine($"      next = {StepName(mwOpen.OpenTypeFqn)}(next);");

            if (hasGlobal)
            {
                sb.AppendLine();
                sb.AppendLine("      // Global middleware (outer)");
                foreach (var mwOpen in globals)
                    sb.AppendLine($"      next = {StepName(mwOpen.OpenTypeFqn)}(next);");
            }

            sb.AppendLine();
            sb.AppendLine("      return next(command, ctxValue, ct);");
            sb.AppendLine("    }");
            sb.AppendLine();

            foreach (var mwOpen in mids)
            {
                var step = StepName(mwOpen.OpenTypeFqn);
                sb.AppendLine($"    private {core}.CommandDelegate<TCommand, {ctx}> {step}({core}.CommandDelegate<TCommand, {ctx}> inner)");
                sb.AppendLine("    {");
                sb.AppendLine($"      return (cmd, ctxValue, ct) => _sp.GetRequiredService<{CloseMiddleware(mwOpen, "TCommand", ctx)}>()");
                sb.AppendLine("        .InvokeAsync(cmd, ctxValue, inner, ct);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            if (hasGlobal)
            {
                foreach (var mwOpen in globals)
                {
                    var step = StepName(mwOpen.OpenTypeFqn);
                    sb.AppendLine($"    private {core}.CommandDelegate<TCommand, {ctx}> {step}({core}.CommandDelegate<TCommand, {ctx}> inner)");
                    sb.AppendLine("    {");
                    sb.AppendLine($"      return (cmd, ctxValue, ct) => _sp.GetRequiredService<{CloseMiddleware(mwOpen, "TCommand", ctx)}>()");
                    sb.AppendLine("        .InvokeAsync(cmd, ctxValue, inner, ct);");
                    sb.AppendLine("    }");
                    sb.AppendLine();
                }
            }

            sb.AppendLine("  }");
            sb.AppendLine();
        }

        // -------------------------
        // 3) Per-command pipelines (closed, highest precedence)
        // -------------------------
        foreach (var kv in perCmd.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            var cmdFqn = kv.Key;
            var mids = kv.Value;
            var className = "TinyDispatcherPipeline_" + SanitizeCommandName(cmdFqn);

            sb.AppendLine($"  internal sealed class {className} : {core}.ICommandPipeline<{cmdFqn}, {ctx}>");
            sb.AppendLine("  {");
            sb.AppendLine("    private readonly IServiceProvider _sp;");
            sb.AppendLine();
            sb.AppendLine($"    public {className}(IServiceProvider sp) => _sp = sp ?? throw new ArgumentNullException(nameof(sp));");
            sb.AppendLine();
            sb.AppendLine("    public Task ExecuteAsync(");
            sb.AppendLine($"        {cmdFqn} command,");
            sb.AppendLine($"        {ctx} ctxValue,");
            sb.AppendLine($"        {core}.ICommandHandler<{cmdFqn}, {ctx}> handler,");
            sb.AppendLine("        CancellationToken ct = default)");
            sb.AppendLine("    {");
            sb.AppendLine("      if (command is null) throw new ArgumentNullException(nameof(command));");
            sb.AppendLine("      if (handler is null) throw new ArgumentNullException(nameof(handler));");
            sb.AppendLine();
            sb.AppendLine($"      {core}.CommandDelegate<{cmdFqn}, {ctx}> next = handler.HandleAsync;");
            sb.AppendLine();
            sb.AppendLine("      // Per-command middleware (inner)");
            foreach (var mwOpen in mids)
                sb.AppendLine($"      next = {StepName(mwOpen.OpenTypeFqn)}(next);");

            if (hasGlobal)
            {
                sb.AppendLine();
                sb.AppendLine("      // Global middleware (outer)");
                foreach (var mwOpen in globals)
                    sb.AppendLine($"      next = {StepName(mwOpen.OpenTypeFqn)}(next);");
            }

            sb.AppendLine();
            sb.AppendLine("      return next(command, ctxValue, ct);");
            sb.AppendLine("    }");
            sb.AppendLine();

            foreach (var mwOpen in mids)
            {
                var step = StepName(mwOpen.OpenTypeFqn);
                sb.AppendLine($"    private {core}.CommandDelegate<{cmdFqn}, {ctx}> {step}({core}.CommandDelegate<{cmdFqn}, {ctx}> inner)");
                sb.AppendLine("    {");
                sb.AppendLine($"      return (cmd, ctxValue, ct) => _sp.GetRequiredService<{CloseMiddleware(mwOpen, cmdFqn, ctx)}>()");
                sb.AppendLine("        .InvokeAsync(cmd, ctxValue, inner, ct);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            if (hasGlobal)
            {
                foreach (var mwOpen in globals)
                {
                    var step = StepName(mwOpen.OpenTypeFqn);
                    sb.AppendLine($"    private {core}.CommandDelegate<{cmdFqn}, {ctx}> {step}({core}.CommandDelegate<{cmdFqn}, {ctx}> inner)");
                    sb.AppendLine("    {");
                    sb.AppendLine($"      return (cmd, ctxValue, ct) => _sp.GetRequiredService<{CloseMiddleware(mwOpen, cmdFqn, ctx)}>()");
                    sb.AppendLine("        .InvokeAsync(cmd, ctxValue, inner, ct);");
                    sb.AppendLine("    }");
                    sb.AppendLine();
                }
            }

            sb.AppendLine("  }");
            sb.AppendLine();
        }
    }

    // ============================================================
    // PARTIAL CONTRIBUTION IMPLEMENTATION (NO DUPLICATE TYPES!)
    // ============================================================

    private void AppendContributionPartialImplementation(StringBuilder sb, DiscoveryResult result, GeneratorOptions options)
    {
        var core = $"global::{Known.CoreNamespace}";
        var ctx = options.CommandContextType!;
        var generatedNsFqn = "global::" + options.GeneratedNamespace;

        var hasGlobal = NormalizeDistinct(_globalMiddlewares).Length > 0;

        var perCmdSet = new HashSet<string>(_perCommand.Keys.Select(NormalizeFullyQualifiedType), StringComparer.Ordinal);

        // Build command -> policyPipelineType mapping (closed by command, but pipeline is open per policy)
        var cmdToPolicyPipeline = new Dictionary<string, string>(StringComparer.Ordinal);
        foreach (var p in _policies.Values)
        {
            var policyName = SanitizePolicyName(p.PolicyTypeFqn);
            var policyPipelineOpen = $"{generatedNsFqn}.TinyDispatcherPolicyPipeline_{policyName}";

            foreach (var cmd in p.Commands.Select(NormalizeFullyQualifiedType))
            {
                // If multiple policies claim same command, first wins deterministically by policy order at call site.
                // (You can later add explicit ordering rules if needed.)
                if (!cmdToPolicyPipeline.ContainsKey(cmd))
                    cmdToPolicyPipeline[cmd] = policyPipelineOpen;
            }
        }

        var policyCmdSet = new HashSet<string>(cmdToPolicyPipeline.Keys, StringComparer.Ordinal);

        // IMPORTANT: same namespace/type as EmptyPipelineContributionEmitter
        sb.AppendLine($"namespace {options.GeneratedNamespace}");
        sb.AppendLine("{");
        sb.AppendLine("  internal static partial class ThisAssemblyPipelineContribution");
        sb.AppendLine("  {");
        sb.AppendLine("    static partial void AddGeneratedPipelines(IServiceCollection services)");
        sb.AppendLine("    {");
        sb.AppendLine("      if (services is null) throw new ArgumentNullException(nameof(services));");
        sb.AppendLine();

        // 1) Per-command pipelines
        foreach (var cmd in perCmdSet.OrderBy(x => x, StringComparer.Ordinal))
        {
            var className = "TinyDispatcherPipeline_" + SanitizeCommandName(cmd);
            sb.AppendLine($"      services.AddTransient<{core}.ICommandPipeline<{cmd}, {ctx}>, {generatedNsFqn}.{className}>();");
        }

        // 2) Policy pipelines (commands without per-command override)
        foreach (var cmd in policyCmdSet.OrderBy(x => x, StringComparer.Ordinal))
        {
            if (perCmdSet.Contains(cmd))
                continue;

            var policyPipelineOpen = cmdToPolicyPipeline[cmd];
            sb.AppendLine(
                $"      services.AddTransient<{core}.IPolicyCommandPipeline<{cmd}, {ctx}>, {policyPipelineOpen}<{cmd}> >();"
                .Replace("> >", ">>"));
        }

        // 3) Global pipelines for remaining commands
        if (hasGlobal && result.Commands.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("      // Global pipeline registrations (commands without per-command overrides or policy pipelines)");
            foreach (var c in result.Commands)
            {
                var cmd = NormalizeFullyQualifiedType(c.MessageTypeFqn);

                if (perCmdSet.Contains(cmd))
                    continue;

                if (policyCmdSet.Contains(cmd))
                    continue;

                sb.AppendLine(
                    $"      services.AddTransient<{core}.IGlobalCommandPipeline<{cmd}, {ctx}>, {generatedNsFqn}.TinyDispatcherGlobalPipeline<{cmd}> >();"
                    .Replace("> >", ">>"));
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("  }");
        sb.AppendLine("}");
    }

    private ResolvedPipeline ResolvePipelineForCommand(
    string commandFqn,
    string ctxFqn,
    string handlerFqn)
    {
        var cmd = NormalizeFullyQualifiedType(commandFqn);
        var ctx = NormalizeFullyQualifiedType(ctxFqn);
        var handler = NormalizeFullyQualifiedType(handlerFqn);

        var globals = NormalizeDistinct(_globalMiddlewares);
        var perCmd = _perCommand.TryGetValue(cmd, out var perCmdMids)
            ? NormalizeDistinct(perCmdMids)
            : Array.Empty<MiddlewareRef>();

        // Determine policy (if any) that claims this command (deterministic order by policy fqn)
        PolicySpec? policy = null;

        foreach (var p in _policies.Values.OrderBy(x => x.PolicyTypeFqn, StringComparer.Ordinal))
        {
            if (p.Commands.Any(c => string.Equals(NormalizeFullyQualifiedType(c), cmd, StringComparison.Ordinal)))
            {
                policy = p;
                break;
            }
        }

        var appliedPolicies = policy is null
            ? ImmutableArray<string>.Empty
            : ImmutableArray.Create(NormalizeFullyQualifiedType(policy.PolicyTypeFqn));

        // Effective middleware order as executed:
        // - Global (outer)
        // - Policy (inner) (if any)
        // - Per-command (inner-most among middleware)
        // - Handler final
        //
        // NOTE: Your generated pipelines currently do:
        // per-command: per-command inner, then global outer
        // policy: policy inner, then global outer
        // So in *execution order* the global runs first, then policy/command, then handler.
        var list = ImmutableArray.CreateBuilder<ResolvedMiddleware>();

        // global (outer)
        foreach (var mw in globals)
            list.Add(new ResolvedMiddleware(mw, "Global"));

        // policy (middle)
        if (policy is not null)
        {
            foreach (var mw in NormalizeDistinct(policy.Middlewares))
                list.Add(new ResolvedMiddleware(mw, $"Policy:{NormalizeFullyQualifiedType(policy.PolicyTypeFqn)}"));
        }

        // per-command (inner-most)
        foreach (var mw in perCmd)
            list.Add(new ResolvedMiddleware(mw, $"Command:{cmd}"));

        return new ResolvedPipeline(
            CommandFqn: cmd,
            ContextFqn: ctx,
            HandlerFqn: handler,
            Middlewares: list.ToImmutable(),
            PoliciesApplied: appliedPolicies);
    }
    private static PipelineDescriptor ToDescriptor(ResolvedPipeline p)
    {
        var mids = p.Middlewares
            .Select(m => new MiddlewareDescriptor(
                MiddlewareFullName: m.Middleware.OpenTypeFqn,
                Source: m.Source))
            .ToArray();

        return new PipelineDescriptor(
            CommandFullName: p.CommandFqn,
            ContextFullName: p.ContextFqn,
            HandlerFullName: p.HandlerFqn,
            Middlewares: mids,
            PoliciesApplied: p.PoliciesApplied.ToArray());
    }



    // ============================================================
    // HELPERS
    // ============================================================

    private static MiddlewareRef[] NormalizeDistinct(ImmutableArray<MiddlewareRef> items)
        => items
            .Where(x => !string.IsNullOrWhiteSpace(x.OpenTypeFqn))
            .Select(x => new MiddlewareRef(NormalizeFullyQualifiedType(x.OpenTypeFqn), x.Arity))
            .Distinct()
            .ToArray();

    private static string[] NormalizeDistinct(ImmutableArray<string> items)
        => items
            .Where(s => !string.IsNullOrWhiteSpace(s))
            .Select(NormalizeFullyQualifiedType)
            .Distinct(StringComparer.Ordinal)
            .ToArray();

    private static string NormalizeFullyQualifiedType(string typeName)
    {
        var trimmed = typeName.Trim();
        if (!trimmed.StartsWith("global::", StringComparison.Ordinal))
            trimmed = "global::" + trimmed;

        return trimmed.StartsWith("global::global::", StringComparison.Ordinal)
            ? "global::" + trimmed.Substring("global::global::".Length)
            : trimmed;
    }

    private static string CloseMiddleware(MiddlewareRef mw, string cmdType, string ctxType)
        => mw.Arity == 2
            ? $"{mw.OpenTypeFqn}<{cmdType}, {ctxType}>"
            : $"{mw.OpenTypeFqn}<{cmdType}>";

    private static string StepName(string openMiddlewareFqn)
    {
        var s = openMiddlewareFqn.StartsWith("global::", StringComparison.Ordinal)
            ? openMiddlewareFqn.Substring("global::".Length)
            : openMiddlewareFqn;

        var lastDot = s.LastIndexOf('.');
        var name = lastDot >= 0 ? s.Substring(lastDot + 1) : s;

        const string suffix = "Middleware";
        if (name.EndsWith(suffix, StringComparison.Ordinal) && name.Length > suffix.Length)
            name = name.Substring(0, name.Length - suffix.Length);

        if (string.IsNullOrWhiteSpace(name))
            name = "Step";

        if (!char.IsLetter(name[0]) && name[0] != '_')
            name = "_" + name;

        return name;
    }

    private static string SanitizeCommandName(string cmdFqn)
    {
        var s = cmdFqn.StartsWith("global::", StringComparison.Ordinal)
            ? cmdFqn.Substring("global::".Length)
            : cmdFqn;

        var lastDot = s.LastIndexOf('.');
        var name = lastDot >= 0 ? s.Substring(lastDot + 1) : s;

        var chars = name.Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray();
        return new string(chars);
    }

    private static string SanitizePolicyName(string policyTypeFqn)
    {
        // "global::ConsoleApp11.CheckoutPolicy" -> "ConsoleApp11_CheckoutPolicy"
        var s = policyTypeFqn.StartsWith("global::", StringComparison.Ordinal)
            ? policyTypeFqn.Substring("global::".Length)
            : policyTypeFqn;

        var chars = s.Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray();
        return new string(chars);
    }

    private sealed record ResolvedPipeline(
        string CommandFqn,
        string ContextFqn,
        string HandlerFqn,
        ImmutableArray<ResolvedMiddleware> Middlewares,
        ImmutableArray<string> PoliciesApplied);

    private sealed record ResolvedMiddleware(
        MiddlewareRef Middleware,
        string Source);
}
