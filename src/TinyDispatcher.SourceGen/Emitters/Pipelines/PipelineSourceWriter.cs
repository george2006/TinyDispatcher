using System;
using System.Collections.Generic;
using System.Linq;
using TinyDispatcher.SourceGen.Generator.Models;
using static TinyDispatcher.SourceGen.Emitters.Pipelines.PipelineEmitter;

namespace TinyDispatcher.SourceGen.Emitters.Pipelines;

internal static class PipelineSourceWriter
{
    public static string Write(PipelinePlan plan)
    {
        var w = new CodeWriter();

        w.Line("// <auto-generated/>");
        w.Line("#nullable enable");
        w.Line("using System;");
        w.Line("using System.Threading;");
        w.Line("using System.Threading.Tasks;");
        w.Line("using Microsoft.Extensions.DependencyInjection;");
        w.Line("using Microsoft.Extensions.DependencyInjection.Extensions;");
        w.Line();

        w.BeginBlock($"namespace {plan.GeneratedNamespace}");

        if (plan.GlobalPipeline is not null)
            WritePipeline(w, plan, plan.GlobalPipeline);

        for (int i = 0; i < plan.PolicyPipelines.Length; i++)
            WritePipeline(w, plan, plan.PolicyPipelines[i]);

        for (int i = 0; i < plan.PerCommandPipelines.Length; i++)
            WritePipeline(w, plan, plan.PerCommandPipelines[i]);

        w.EndBlock(); // namespace

        w.Line();

        w.BeginBlock($"namespace {plan.GeneratedNamespace}");
        WriteContribution(w, plan);
        w.EndBlock(); // namespace

        w.EnsureAllBlocksClosed();
        return w.ToString();
    }

    private static void WritePipeline(CodeWriter w, PipelinePlan plan, PipelineDefinition def)
    {
        var core = plan.CoreFqn;
        var ctx = plan.ContextFqn;

        var cmdType = def.IsOpenGeneric ? "TCommand" : def.CommandType;

        if (def.IsOpenGeneric)
        {
            // Emit class header + where clause, then open the body WITHOUT re-emitting "class ..."
            w.Line(
                $"internal sealed class {def.ClassName}<TCommand> : " +
                $"{core}.ICommandPipeline<TCommand, {ctx}>");
            w.Line($"  where TCommand : {core}.ICommand");

            // Open anonymous block with no header => just "{"
            w.BeginAnonymousBlock(string.Empty);
        }
        else
        {
            w.BeginBlock(
                $"internal sealed class {def.ClassName} : " +
                $"{core}.ICommandPipeline<{def.CommandType}, {ctx}>");
        }

        // Fields (distinct by open type + arity)
        var mwDistinct = MiddlewareSets
            .DistinctByOpenTypeAndArity(def.Steps.Select(s => s.Middleware))
            .ToArray();

        for (int i = 0; i < mwDistinct.Length; i++)
        {
            var mw = mwDistinct[i];
            w.Line($"private readonly {TypeNames.CloseMiddleware(mw, cmdType, ctx)} {NameFactory.FieldName(mw)};");
        }

        w.Line();

        // Runtime state is per ExecuteAsync invocation (thread-safe / re-entrant)
        WriteRuntimeClass(w, plan, def, cmdType);
        w.Line();

        WriteCtor(w, plan, def, cmdType, mwDistinct);
        WriteExecute(w, plan, def, cmdType);

        w.EndBlock(); // class body
        w.Line();
    }

    private static void WriteRuntimeClass(CodeWriter w, PipelinePlan plan, PipelineDefinition def, string cmdType)
    {
        var core = plan.CoreFqn;
        var ctx = plan.ContextFqn;

        // The concrete pipeline type used inside the nested Runtime class
        var pipelineType = def.IsOpenGeneric
            ? $"{def.ClassName}<TCommand>"
            : def.ClassName;

        // The handler type depends on open/closed pipeline
        var handlerType = def.IsOpenGeneric
            ? $"{core}.ICommandHandler<TCommand, {ctx}>"
            : $"{core}.ICommandHandler<{def.CommandType}, {ctx}>";

        w.BeginBlock($"private sealed class Runtime : {core}.Pipeline.ICommandPipelineRuntime<{cmdType}, {ctx}>");
        w.Line($"private readonly {pipelineType} _pipeline;");
        w.Line($"private readonly {handlerType} _handler;");
        w.Line("private int _index;");
        w.Line();

        w.BeginBlock($"public Runtime({pipelineType} pipeline, {handlerType} handler)");
        w.Line("_pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));");
        w.Line("_handler = handler ?? throw new ArgumentNullException(nameof(handler));");
        w.Line("_index = 0;");
        w.EndBlock();
        w.Line();

        // Entry point used by ExecuteAsync
        w.BeginBlock($"public ValueTask StartAsync({cmdType} command, {ctx} ctxValue, CancellationToken ct)");
        w.Line("return NextAsyncInternal(command, ctxValue, ct);");
        w.EndBlock();
        w.Line();

        w.BeginBlock($"private ValueTask NextAsyncInternal({cmdType} command, {ctx} ctxValue, CancellationToken ct)");
        w.BeginBlock("switch (_index++)");

        for (int i = 0; i < def.Steps.Length; i++)
        {
            var mw = def.Steps[i].Middleware;
            w.Line($"case {i}: return _pipeline.{NameFactory.FieldName(mw)}.InvokeAsync(command, ctxValue, this, ct);");
        }

        w.Line("default: return new ValueTask(_handler.HandleAsync(command, ctxValue, ct));");
        w.EndBlock(); // switch
        w.EndBlock(); // method
        w.Line();

        // Explicit interface implementation
        w.BeginBlock(
            $"ValueTask {core}.Pipeline.ICommandPipelineRuntime<{cmdType}, {ctx}>.NextAsync({cmdType} command, {ctx} ctxValue, CancellationToken ct)");
        w.Line("return NextAsyncInternal(command, ctxValue, ct);");
        w.EndBlock();

        w.EndBlock(); // class Runtime
    }

    private static void WriteCtor(CodeWriter w, PipelinePlan plan, PipelineDefinition def, string cmdType, MiddlewareRef[] mwDistinct)
    {
        var ctx = plan.ContextFqn;

        // Constructor name does NOT include generic args in C#
        w.Line($"public {def.ClassName}(");
        for (int i = 0; i < mwDistinct.Length; i++)
        {
            var mw = mwDistinct[i];
            var comma = (i == mwDistinct.Length - 1) ? "" : ",";
            w.Line($"  {TypeNames.CloseMiddleware(mw, cmdType, ctx)} {NameFactory.CtorParamName(mw)}{comma}");
        }
        w.Line(")");
        w.BeginAnonymousBlock(string.Empty);

        for (int i = 0; i < mwDistinct.Length; i++)
        {
            var mw = mwDistinct[i];
            w.Line($"{NameFactory.FieldName(mw)} = {NameFactory.CtorParamName(mw)};");
        }

        w.EndBlock();
        w.Line();
    }

    private static void WriteExecute(CodeWriter w, PipelinePlan plan, PipelineDefinition def, string cmdType)
    {
        var core = plan.CoreFqn;
        var ctx = plan.ContextFqn;

        var handlerType = def.IsOpenGeneric
            ? $"{core}.ICommandHandler<TCommand, {ctx}>"
            : $"{core}.ICommandHandler<{def.CommandType}, {ctx}>";

        var cmdSig = def.IsOpenGeneric ? "TCommand" : def.CommandType;

        w.BeginBlock($"public ValueTask ExecuteAsync({cmdSig} command, {ctx} ctxValue, {handlerType} handler)");
        w.Line("return ExecuteAsync(command, ctxValue, handler, default);");
        w.EndBlock();
        w.Line();

        w.BeginBlock($"public ValueTask ExecuteAsync({cmdSig} command, {ctx} ctxValue, {handlerType} handler, CancellationToken ct)");
        w.Line("if (command is null) throw new ArgumentNullException(nameof(command));");
        w.Line("if (handler is null) throw new ArgumentNullException(nameof(handler));");
        w.Line("var runtime = new Runtime(this, handler);");
        w.Line("return runtime.StartAsync(command, ctxValue, ct);");
        w.EndBlock();
        w.Line();
    }

    private static void WriteContribution(CodeWriter w, PipelinePlan plan)
    {
        w.BeginBlock("internal static partial class ThisAssemblyPipelineContribution");
        w.BeginBlock("static partial void AddGeneratedPipelines(IServiceCollection services)");
        w.Line("if (services is null) throw new ArgumentNullException(nameof(services));");
        w.Line();

        if (plan.OpenGenericMiddlewareRegistrations.Length > 0)
        {
            w.Line("// Middleware open-generic registrations (required for generated pipelines ctor injection)");
            for (int i = 0; i < plan.OpenGenericMiddlewareRegistrations.Length; i++)
                w.Line($"services.TryAddTransient(typeof({plan.OpenGenericMiddlewareRegistrations[i].TypeofExpression}));");
            w.Line();
        }

        for (int i = 0; i < plan.ServiceRegistrations.Length; i++)
        {
            var r = plan.ServiceRegistrations[i];
            w.Line($"services.AddScoped<{r.ServiceTypeExpression}, {r.ImplementationTypeExpression}>();");
        }

        w.EndBlock(); // method
        w.EndBlock(); // class
    }
}