using System;
using System.Collections.Generic;
using System.Text;
using TinyDispatcher.SourceGen.Generator.Models;
using static TinyDispatcher.SourceGen.Emitters.Pipelines.PipelineEmitter;

namespace TinyDispatcher.SourceGen.Emitters.Pipelines;

internal static class PipelineSourceWriter
{
    public static string Write(PipelinePlan plan)
    {
        var w = new CodeWriter();

        w.Line("// <auto-generated/>");
        w.Line("#nullable enable");
        w.Line("using System;");
        w.Line("using System.Threading;");
        w.Line("using System.Threading.Tasks;");
        w.Line("using Microsoft.Extensions.DependencyInjection;");
        w.Line("using Microsoft.Extensions.DependencyInjection.Extensions;");
        w.Line();

        w.BeginBlock($"namespace {plan.GeneratedNamespace}");

        if (plan.GlobalPipeline is not null)
            WritePipeline(w, plan, plan.GlobalPipeline);

        for (int i = 0; i < plan.PolicyPipelines.Length; i++)
            WritePipeline(w, plan, plan.PolicyPipelines[i]);

        for (int i = 0; i < plan.PerCommandPipelines.Length; i++)
            WritePipeline(w, plan, plan.PerCommandPipelines[i]);

        w.EndBlock(); // namespace

        w.Line();

        w.BeginBlock($"namespace {plan.GeneratedNamespace}");
        WriteContribution(w, plan);
        w.EndBlock(); // namespace

        w.EnsureAllBlocksClosed();
        return w.ToString();
    }

    private static void WritePipeline(CodeWriter w, PipelinePlan plan, PipelineDefinition def)
    {
        var core = plan.CoreFqn;
        var ctx = plan.ContextFqn;
        var cmdType = def.IsOpenGeneric ? "TCommand" : def.CommandType;

        if (def.IsOpenGeneric)
        {
            // IMPORTANT: do NOT use BeginBlock for "where". Emit where line, then open the class body as an anonymous block.
            w.Line($"internal sealed class {def.ClassName}<TCommand> : {core}.ICommandPipeline<TCommand, {ctx}>");
            w.Line($"  where TCommand : {core}.ICommand");
            w.BeginAnonymousBlock($"class {def.ClassName}<TCommand>");
        }
        else
        {
            w.BeginBlock($"internal sealed class {def.ClassName} : {core}.ICommandPipeline<{def.CommandType}, {ctx}>");
        }

        // Fields (distinct by open type + arity)
        var mwDistinct = MiddlewareSets
            .DistinctByOpenTypeAndArity(def.Steps.Select(s => s.Middleware))
            .ToArray();

        for (int i = 0; i < mwDistinct.Length; i++)
        {
            var mw = mwDistinct[i];
            w.Line($"private readonly {TypeNames.CloseMiddleware(mw, cmdType, ctx)} {NameFactory.FieldName(mw)};");
        }

        w.Line("private int _index;");

        if (def.IsOpenGeneric)
            w.Line($"private {core}.ICommandHandler<TCommand, {ctx}>? _handler;");
        else
            w.Line($"private {core}.ICommandHandler<{def.CommandType}, {ctx}>? _handler;");

        w.Line("private readonly Runtime _runtime;");
        w.Line();

        WriteCtor(w, plan, def, cmdType, mwDistinct);
        WriteExecute(w, plan, def, cmdType);
        WriteNext(w, plan, def, cmdType);
        WriteRuntime(w, plan, def, cmdType);

        w.EndBlock(); // class body
        w.Line();
    }

    private static void WriteCtor(CodeWriter w, PipelinePlan plan, PipelineDefinition def, string cmdType, MiddlewareRef[] mwDistinct)
    {
        var ctx = plan.ContextFqn;

        // ctor signature (NON-generic name!)
        w.Line($"public {def.ClassName}(");
        for (int i = 0; i < mwDistinct.Length; i++)
        {
            var mw = mwDistinct[i];
            var comma = (i == mwDistinct.Length - 1) ? "" : ",";
            w.Line($"  {TypeNames.CloseMiddleware(mw, cmdType, ctx)} {NameFactory.CtorParamName(mw)}{comma}");
        }
        w.Line(")");
        w.BeginAnonymousBlock($"ctor {def.ClassName}");

        for (int i = 0; i < mwDistinct.Length; i++)
        {
            var mw = mwDistinct[i];
            w.Line($"{NameFactory.FieldName(mw)} = {NameFactory.CtorParamName(mw)};");
        }

        w.Line("_runtime = new Runtime(this);");
        w.EndBlock();

        w.Line();
    }

    private static void WriteExecute(CodeWriter w, PipelinePlan plan, PipelineDefinition def, string cmdType)
    {
        var core = plan.CoreFqn;
        var ctx = plan.ContextFqn;

        var handlerType = def.IsOpenGeneric
            ? $"{core}.ICommandHandler<TCommand, {ctx}>"
            : $"{core}.ICommandHandler<{def.CommandType}, {ctx}>";

        var cmdSig = def.IsOpenGeneric ? "TCommand" : def.CommandType;

        w.BeginBlock($"public ValueTask ExecuteAsync({cmdSig} command, {ctx} ctxValue, {handlerType} handler, CancellationToken ct = default)");
        w.Line("if (command is null) throw new ArgumentNullException(nameof(command));");
        w.Line("if (handler is null) throw new ArgumentNullException(nameof(handler));");
        w.Line("_handler = handler;");
        w.Line("_index = 0;");
        w.Line("return NextAsync(command, ctxValue, ct);");
        w.EndBlock();
        w.Line();
    }

    private static void WriteNext(CodeWriter w, PipelinePlan plan, PipelineDefinition def, string cmdType)
    {
        var ctx = plan.ContextFqn;

        w.BeginBlock($"private ValueTask NextAsync({cmdType} command, {ctx} ctxValue, CancellationToken ct)");
        w.BeginBlock("switch (_index++)");

        for (int i = 0; i < def.Steps.Length; i++)
        {
            var mw = def.Steps[i].Middleware;
            w.Line($"case {i}: return {NameFactory.FieldName(mw)}.InvokeAsync(command, ctxValue, _runtime, ct);");
        }

        w.Line("default: return new ValueTask(_handler!.HandleAsync(command, ctxValue, ct));");
        w.EndBlock(); // switch
        w.EndBlock(); // method
        w.Line();
    }

    private static void WriteRuntime(CodeWriter w, PipelinePlan plan, PipelineDefinition def, string cmdType)
    {
        var core = plan.CoreFqn;
        var ctx = plan.ContextFqn;

        w.BeginBlock($"private sealed class Runtime : {core}.Pipeline.ICommandPipelineRuntime<{cmdType}, {ctx}>");

        var pipelineType = def.IsOpenGeneric ? $"{def.ClassName}<TCommand>" : def.ClassName;

        w.Line($"private readonly {pipelineType} _p;");
        w.Line($"public Runtime({pipelineType} p) {{ _p = p; }}");

        w.BeginBlock($"public ValueTask NextAsync({cmdType} command, {ctx} ctxValue, CancellationToken ct = default)");
        w.Line("return _p.NextAsync(command, ctxValue, ct);");
        w.EndBlock();

        w.EndBlock(); // Runtime
    }

    private static void WriteContribution(CodeWriter w, PipelinePlan plan)
    {
        w.BeginBlock("internal static partial class ThisAssemblyPipelineContribution");
        w.BeginBlock("static partial void AddGeneratedPipelines(IServiceCollection services)");
        w.Line("if (services is null) throw new ArgumentNullException(nameof(services));");
        w.Line();

        if (plan.OpenGenericMiddlewareRegistrations.Length > 0)
        {
            w.Line("// Middleware open-generic registrations (required for generated pipelines ctor injection)");
            for (int i = 0; i < plan.OpenGenericMiddlewareRegistrations.Length; i++)
                w.Line($"services.TryAddTransient(typeof({plan.OpenGenericMiddlewareRegistrations[i].TypeofExpression}));");
            w.Line();
        }

        for (int i = 0; i < plan.ServiceRegistrations.Length; i++)
        {
            var r = plan.ServiceRegistrations[i];
            w.Line($"services.AddScoped<{r.ServiceTypeExpression}, {r.ImplementationTypeExpression}>();");
        }

        w.EndBlock(); // method
        w.EndBlock(); // class
    }
}