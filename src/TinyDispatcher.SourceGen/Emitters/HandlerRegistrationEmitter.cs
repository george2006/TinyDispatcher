// FILE: src/TinyDispatcher.SourceGen/HandlerRegistrationsEmitter.cs
// NEW FILE. Emits the partial method implementation that registers ALL discovered handlers into DI.
// This restores the "handlers auto-registered into IServiceCollection" behavior.

using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis.Text;
using TinyDispatcher.SourceGen.Abstractions;

namespace TinyDispatcher.SourceGen;

public sealed class HandlerRegistrationsEmitter : ICodeEmitter
{
    public void Emit(IGeneratorContext context, DiscoveryResult result, GeneratorOptions options)
    {
        var ns = options.GeneratedNamespace;

        // If disabled, still emit an empty partial method so compilation is always valid.
        if (!options.EmitHandlerRegistrations)
        {
            EmitEmpty(context, ns);
            return;
        }

        var handlerTypeFqns =
            result.Commands.Select(c => c.HandlerTypeFqn)
                .Concat(result.Queries.Select(q => q.HandlerTypeFqn))
                .Where(x => !string.IsNullOrWhiteSpace(x))
                .Distinct(StringComparer.Ordinal)
                .OrderBy(x => x, StringComparer.Ordinal)
                .ToArray();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine("  internal static partial class ThisAssemblyPipelineContribution");
        sb.AppendLine("  {");
        sb.AppendLine("    static partial void AddGeneratedHandlers(IServiceCollection services)");
        sb.AppendLine("    {");
        sb.AppendLine("      if (services is null) throw new ArgumentNullException(nameof(services));");

        // Use typeof(FQN) to avoid generic name formatting headaches.
        foreach (var fqn in handlerTypeFqns)
            sb.AppendLine($"      services.AddTransient(typeof({fqn}));");

        sb.AppendLine("    }");
        sb.AppendLine("  }");
        sb.AppendLine("}");

        context.AddSource("ThisAssemblyHandlerRegistrations.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitEmpty(IGeneratorContext context, string ns)
    {
        var source = $$"""
        // <auto-generated/>
        #nullable enable
        using Microsoft.Extensions.DependencyInjection;

        namespace {{ns}}
        {
          internal static partial class ThisAssemblyPipelineContribution
          {
            static partial void AddGeneratedHandlers(IServiceCollection services) { }
          }
        }
        """;

        context.AddSource("ThisAssemblyHandlerRegistrations.g.cs", SourceText.From(source, Encoding.UTF8));
    }
}
