using Microsoft.CodeAnalysis.Text;
using System.Text;
using TinyDispatcher.SourceGen;
using TinyDispatcher.SourceGen.Abstractions;
using TinyDispatcher.SourceGen.Generator.Models;

public sealed class HandlerRegistrationsEmitter : ICodeEmitter
{
    public void Emit(IGeneratorContext context, DiscoveryResult result, GeneratorOptions options)
    {
        var ns = options.GeneratedNamespace;

        // Always emit a valid partial method.
        if (!options.EmitHandlerRegistrations)
        {
            EmitEmpty(context, ns);
            return;
        }

        // We need a context type to register ICommandHandler<TCommand,TContext>.
        // (Queries do not require it, but we keep a single consistent codepath.)
        var ctx = options.CommandContextType;
        if (string.IsNullOrWhiteSpace(ctx))
        {
            // If there are commands, we cannot register them safely.
            // Best hardening: emit empty method and rely on runtime DI failure (clear error).
            // (If you prefer: add a generator diagnostic here.)
            EmitEmpty(context, ns);
            return;
        }

        var ctxFqn = Fqn.EnsureGlobal(ctx!);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine("  internal static partial class ThisAssemblyPipelineContribution");
        sb.AppendLine("  {");
        sb.AppendLine("    static partial void AddGeneratedHandlers(IServiceCollection services)");
        sb.AppendLine("    {");
        sb.AppendLine("      if (services is null) throw new ArgumentNullException(nameof(services));");
        sb.AppendLine();

        // Commands: ICommandHandler<TCommand, TContext> -> Handler
        foreach (var c in result.Commands
                     .OrderBy(x => x.MessageTypeFqn, StringComparer.Ordinal)
                     .ThenBy(x => x.HandlerTypeFqn, StringComparer.Ordinal))
        {
            sb.AppendLine(
                $"      services.AddTransient(typeof(global::TinyDispatcher.ICommandHandler<{c.MessageTypeFqn}, {ctxFqn}>), typeof({c.HandlerTypeFqn}));");
        }

        if (result.Commands.Length > 0 && result.Queries.Length > 0)
            sb.AppendLine();

        // Queries: IQueryHandler<TQuery, TResult> -> Handler
        foreach (var q in result.Queries
                     .OrderBy(x => x.QueryTypeFqn, StringComparer.Ordinal)
                     .ThenBy(x => x.ResultTypeFqn, StringComparer.Ordinal)
                     .ThenBy(x => x.HandlerTypeFqn, StringComparer.Ordinal))
        {
            sb.AppendLine(
                $"      services.AddTransient(typeof(global::TinyDispatcher.IQueryHandler<{q.QueryTypeFqn}, {q.ResultTypeFqn}>), typeof({q.HandlerTypeFqn}));");
        }

        sb.AppendLine("    }");
        sb.AppendLine("  }");
        sb.AppendLine("}");

        context.AddSource("ThisAssemblyHandlerRegistrations.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitEmpty(IGeneratorContext context, string ns)
    {
        var source = $$"""
        // <auto-generated/>
        #nullable enable
        using Microsoft.Extensions.DependencyInjection;

        namespace {{ns}}
        {
          internal static partial class ThisAssemblyPipelineContribution
          {
            static partial void AddGeneratedHandlers(IServiceCollection services) { }
          }
        }
        """;

        context.AddSource("ThisAssemblyHandlerRegistrations.g.cs", SourceText.From(source, Encoding.UTF8));
    }
}
